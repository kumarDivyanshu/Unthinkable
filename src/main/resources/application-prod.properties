# MySQL (Production)
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
#spring.datasource.url=jdbc:mysql://${DB_HOST}:${DB_PORT:3306}/${DB_NAME}?useSSL=${DB_USE_SSL:true}&allowPublicKeyRetrieval=${DB_ALLOW_PUBLIC_KEY_RETRIEVAL:false}&serverTimezone=UTC&characterEncoding=UTF-8
spring.datasource.username=${DB_USER}
spring.datasource.password=${DB_PASSWORD}
spring.config.import=optional:file:.env[.properties],optional:file:./Unthinkable/.env[.properties],optional:classpath:.env[.properties]

spring.datasource.url=jdbc:mysql:///${DB_NAME}?cloudSqlInstance=${DB_CLOUD_SQL_INSTANCE}&socketFactory=com.google.cloud.sql.mysql.SocketFactory&enabledTLSProtocols=TLSv1.2&serverTimezone=UTC&characterEncoding=UTF-8&tcpKeepAlive=true&socketTimeout=0

# JPA settings
spring.jpa.hibernate.ddl-auto=none
spring.jpa.show-sql=false
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQLDialect
spring.jpa.open-in-view=false

# HikariCP - Aggressive recycling for Cloud SQL
spring.datasource.hikari.pool-name=CloudSqlHikariPool
spring.datasource.hikari.maximum-pool-size=10
spring.datasource.hikari.minimum-idle=2
spring.datasource.hikari.connection-timeout=30000
spring.datasource.hikari.idle-timeout=90000
spring.datasource.hikari.max-lifetime=90000
spring.datasource.hikari.keepalive-time=20000
spring.datasource.hikari.validation-timeout=5000
spring.datasource.hikari.connection-test-query=SELECT 1
spring.datasource.hikari.initialization-fail-timeout=30000
spring.datasource.hikari.auto-commit=true

# JWT (configure via env var in prod)
app.jwt.secret=${APP_JWT_SECRET}
app.jwt.expiration-ms=${APP_JWT_EXPIRATION_MS:86400000}

# Disable H2 console in prod
spring.h2.console.enabled=false

# Force async processing in prod so uploads are queued, not processed in request thread
app.processing.async=true

# RabbitMQ connection (default prod port 5672)
spring.rabbitmq.host=${RABBIT_HOST:localhost}
spring.rabbitmq.port=${RABBIT_PORT:5672}
spring.rabbitmq.username=${RABBIT_USER:guest}
spring.rabbitmq.password=${RABBIT_PASS:guest}
app.rabbitmq.exchange=${RABBIT_EXCHANGE:meeting.exchange}
app.rabbitmq.queue=${RABBIT_QUEUE:meeting.jobs}
app.rabbitmq.routing=${RABBIT_ROUTING:meeting.process}
# Limit worker concurrency to reduce DB contention and long-held connections
spring.rabbitmq.listener.simple.concurrency=${RABBIT_CONCURRENCY:1}
spring.rabbitmq.listener.simple.max-concurrency=${RABBIT_MAX_CONCURRENCY:1}
spring.rabbitmq.listener.simple.prefetch=${RABBIT_PREFETCH:1}
spring.rabbitmq.listener.simple.acknowledge-mode=auto

# ASR provider
app.asr.provider=${ASR_PROVIDER:gcp}

# Gemini (ASR)
app.gemini.api-key=${GEMINI_API_KEY:}
app.gemini.model=${GEMINI_CHAT_MODEL:gemini-2.0-flash}

# Google Cloud Speech-to-Text (ASR)
app.gcp.credentials-path=${GCP_CREDENTIALS_PATH:}
app.gcp.language-code=${GCP_LANGUAGE_CODE:en-US}
app.gcp.bucket=${GCP_BUCKET:}

# FFmpeg path
app.ffmpeg.path=${FFMPEG_PATH:${APP_FFMPEG_PATH:ffmpeg}}

# LLM provider
app.llm.provider=${LLM_PROVIDER:gemini}
app.ollama.base-url=${OLLAMA_BASE_URL:http://localhost:11434}
app.ollama.model=${OLLAMA_MODEL:llama3.1}

# Mail (SMTP) config
app.mail.enabled=${MAIL_ENABLED:false}
app.mail.from=${MAIL_FROM:noreply@example.com}
app.mail.attach-pdf=${MAIL_ATTACH_PDF:false}
spring.mail.host=${MAIL_HOST:}
spring.mail.port=${MAIL_PORT:587}
spring.mail.username=${MAIL_USERNAME:}
spring.mail.password=${MAIL_PASSWORD:}
spring.mail.properties.mail.smtp.auth=${MAIL_SMTP_AUTH:true}
spring.mail.properties.mail.smtp.starttls.enable=${MAIL_SMTP_STARTTLS:true}
spring.mail.properties.mail.smtp.starttls.required=${MAIL_SMTP_STARTTLS_REQUIRED:true}
spring.mail.properties.mail.smtp.ssl.trust=${MAIL_SMTP_SSL_TRUST:smtp.gmail.com}
spring.mail.properties.mail.smtp.ssl.protocols=${MAIL_SMTP_SSL_PROTOCOLS:TLSv1.2}
spring.mail.properties.mail.smtp.ssl.checkserveridentity=${MAIL_SMTP_SSL_CHECKSERVERIDENTITY:false}
spring.mail.properties.mail.smtp.ssl.enable=${MAIL_SMTP_SSL_ENABLE:false}
spring.mail.properties.mail.smtp.connectiontimeout=${MAIL_SMTP_CONNECTION_TIMEOUT:10000}
spring.mail.properties.mail.smtp.timeout=${MAIL_SMTP_TIMEOUT:10000}
spring.mail.properties.mail.smtp.writetimeout=${MAIL_SMTP_WRITETIMEOUT:10000}

# Increase upload limits for large audio files
spring.servlet.multipart.max-file-size=${MAX_FILE_SIZE:500MB}
spring.servlet.multipart.max-request-size=${MAX_REQUEST_SIZE:500MB}
# Stream multipart parts to disk sooner to reduce memory usage
spring.servlet.multipart.file-size-threshold=${FILE_SIZE_THRESHOLD:2MB}

# Server timeouts to accommodate slow/large uploads
server.tomcat.connection-timeout=${SERVER_CONNECTION_TIMEOUT_MS:300000}
# Allow swallowing large requests (unlimited)
server.tomcat.max-swallow-size=${TOMCAT_MAX_SWALLOW_SIZE:-1}
# In case of large form posts (not typical for multipart), raise limit
server.tomcat.max-http-form-post-size=${TOMCAT_MAX_HTTP_FORM_POST_SIZE:100MB}

# Increase async request timeout (used by some internal flows)
spring.mvc.async.request-timeout=${SPRING_ASYNC_REQUEST_TIMEOUT_MS:600000}
