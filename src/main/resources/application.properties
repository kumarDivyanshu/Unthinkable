spring.application.name=Summarizer

# Load .env if present (from working dir, module path, or classpath)
spring.config.import=optional:file:.env[.properties],optional:file:./Unthinkable/.env[.properties],optional:classpath:.env[.properties]

# Profiles: set via env SPRING_PROFILES_ACTIVE or CLI --spring.profiles.active
# Examples:
#   SPRING_PROFILES_ACTIVE=dev   (for local dev)
#   SPRING_PROFILES_ACTIVE=prod  (for production)
spring.profiles.active=prod

# JPA/Hibernate
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=false
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.H2Dialect

# H2 database (file-based for persistence during dev)
spring.datasource.url=jdbc:h2:file:./build/h2db/meetings;MODE=MySQL;AUTO_SERVER=TRUE
spring.datasource.driver-class-name=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=
spring.h2.console.enabled=true
spring.h2.console.path=/h2-console

# Multipart upload limits (adjust as needed)
spring.servlet.multipart.max-file-size=100MB
spring.servlet.multipart.max-request-size=100MB

# JWT default secret for dev (base64). Replace via env APP_JWT_SECRET in prod.
app.jwt.secret=YXQtZGV2LXNlY3JldC1zaG91bGQtYmUtMzItYnl0ZXMtYmFzZTY0
app.jwt.expiration-ms=86400000

# File storage
app.storage.base-dir=./build/uploads

# Processing mode: async uses RabbitMQ; sync runs in request thread
app.processing.async=${PROCESS_ASYNC:true}

# RabbitMQ connection (Docker mapped ports default to 5673 and 15673)
spring.rabbitmq.host=${RABBIT_HOST:localhost}
spring.rabbitmq.port=${RABBIT_PORT:5673}
spring.rabbitmq.username=${RABBIT_USER:guest}
spring.rabbitmq.password=${RABBIT_PASS:guest}
app.rabbitmq.exchange=${RABBIT_EXCHANGE:meeting.exchange}
app.rabbitmq.queue=${RABBIT_QUEUE:meeting.jobs}
app.rabbitmq.routing=${RABBIT_ROUTING:meeting.process}

# ASR provider: 'openai', 'gemini', or 'gcp'
app.asr.provider=${ASR_PROVIDER:gcp}


# Gemini (ASR)
app.gemini.api-key=${GEMINI_API_KEY:}
app.gemini.model=${GEMINI_CHAT_MODEL:gemini-2.0-flash}

# Google Cloud Speech-to-Text (ASR)
app.gcp.credentials-path=${GCP_CREDENTIALS_PATH:}
app.gcp.language-code=${GCP_LANGUAGE_CODE:en-US}
app.gcp.bucket=${GCP_BUCKET:}

# FFmpeg path (Windows: support both FFMPEG_PATH and APP_FFMPEG_PATH)
app.ffmpeg.path=${FFMPEG_PATH:${APP_FFMPEG_PATH:ffmpeg}}

# LLM provider: 'openai' or 'ollama'
app.llm.provider=${LLM_PROVIDER:gemini}
app.ollama.base-url=${OLLAMA_BASE_URL:http://localhost:11434}
app.ollama.model=${OLLAMA_MODEL:llama3.1}

# Mail (SMTP) config
app.mail.enabled=${MAIL_ENABLED:false}
app.mail.from=${MAIL_FROM:noreply@example.com}
app.mail.attach-pdf=${MAIL_ATTACH_PDF:false}
spring.mail.host=${MAIL_HOST:}
spring.mail.port=${MAIL_PORT:587}
spring.mail.username=${MAIL_USERNAME:}
spring.mail.password=${MAIL_PASSWORD:}
spring.mail.properties.mail.smtp.auth=${MAIL_SMTP_AUTH:true}
spring.mail.properties.mail.smtp.starttls.enable=${MAIL_SMTP_STARTTLS:true}
# Require STARTTLS for port 587
spring.mail.properties.mail.smtp.starttls.required=${MAIL_SMTP_STARTTLS_REQUIRED:true}
# Trust Gmail by default; override via MAIL_SMTP_SSL_TRUST
spring.mail.properties.mail.smtp.ssl.trust=${MAIL_SMTP_SSL_TRUST:smtp.gmail.com}
# TLS protocol hint (some JDKs need this)
spring.mail.properties.mail.smtp.ssl.protocols=${MAIL_SMTP_SSL_PROTOCOLS:TLSv1.2}
# Optionally enforce hostname check (set to true to enforce)
spring.mail.properties.mail.smtp.ssl.checkserveridentity=${MAIL_SMTP_SSL_CHECKSERVERIDENTITY:false}
# If using port 465 (implicit SSL), enable SSL and typically disable starttls
spring.mail.properties.mail.smtp.ssl.enable=${MAIL_SMTP_SSL_ENABLE:false}
# Timeouts (ms)
spring.mail.properties.mail.smtp.connectiontimeout=${MAIL_SMTP_CONNECTION_TIMEOUT:10000}
spring.mail.properties.mail.smtp.timeout=${MAIL_SMTP_TIMEOUT:10000}
spring.mail.properties.mail.smtp.writetimeout=${MAIL_SMTP_WRITETIMEOUT:10000}
